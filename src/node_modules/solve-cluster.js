"use strict";

var _ = require("lodash");
var cluster = require("cluster");
var parse = require("parse");
var heatMap = require("heat-map.js");
var unparse = require("unparse");
var fs = require("fs");
var cpus = require("os").cpus().length; // 4 cores

module.exports = solve;

var DIFFERENT_PATHS = 53;
var NB_FORK = 8;//cpus; // or 10;
var NB_LOOP = 5000;
var DELAY = 1;
var inputFile = "./input.txt";
var tempFile = "./problem.tmp";

function solve() {
  fs.readFile(tempFile, function(readFileErr, problem) {
    if (!readFileErr && problem) {
      compute(JSON.parse(problem));
    } else {
      fs.readFile(inputFile, function(readFileInputErr, input) {
        if (readFileInputErr) throw readFileInputErr;
        var flow = _.memoize(_.flow(parse, heatMap));
        var newProblem = flow(input.toString());
        fs.writeFile(tempFile, JSON.stringify(newProblem), function(writeFileErr) {
          if (writeFileErr) throw writeFileErr;
        });
        compute(newProblem);
      });
    }
  });
}

function compute(problem) {

  if (cluster.isMaster) {
    var nbworker = 0;
    var bestPathOver;
    var bestScoreOver = 0;

    _.times(NB_FORK, function() {
      var worker = cluster.fork();
      worker.on("message", function(bestOnesChild) {
        if (bestScoreOver < bestOnesChild.score) {
          bestPathOver = bestOnesChild.path;
          bestScoreOver = bestOnesChild.score;
          console.log("bestScore :", bestScoreOver);

        }
      });
    });
    cluster.on("exit", function(worker, code, signal) {
      //console.log("worker " + worker.process.pid + " died >"+bestOnesOver.length);
      nbworker += 1;
      if (nbworker >= NB_FORK - 1) {
        //var resbestOnesOver = bestPathOver;//_(bestOnesOver).flatten().sortByAll("score", "id").reverse().take(DIFFERENT_PATHS).value();
        console.log("Best loon score ever > ", bestPathOver[0].score, " on ", bestPathOver.length);
//        var paths = _.times(problem.nloons, function(iloon) {
//          //if (!resbestOnesOver[iloon % DIFFERENT_PATHS].moves) throw new Error("no moves found");
//          //return delay(problem, resbestOnesOver[iloon % DIFFERENT_PATHS].moves, DELAY * iloon);
//        });
        var paths = _.times(problem.nloons, function(iloon) {
          return bestPathOver[iloon].moves;
        });
        var movesToPrint = transpose(paths);
        finishTheWork(movesToPrint);
      }
    });
  } else {
    //_.cloneDeep(problem);
    var bestOneForChild;
    var bestScoreForChild = 0;

    var xLimit = _.range(-5, 5);//_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2));
    var yLimit = _.range(-5, 5);//_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2));
    //TODO add a total score to keep the universe ...var total_score = 0;
    _.times(NB_LOOP, function() {
      var currentScore = 0;
      var loons = _.times(problem.nloons, function(iloon) {
        return _.assign({id: iloon, altitude: 0}, problem.home);
      });
      _.times(problem.nsteps, function(istep) {
        return _(loons)
          .map(function chooseMove(loon) {
            //block the launch with a delay of 1
            if (loon.id >= istep) return {x: loon.x, y: loon.y, move: 0, wind: {x: 0, y: 0}};
            if (loon.isLost) return;
            var possibleMoves = getPossibleMoves(problem, loon);
            return _(possibleMoves)
              .map(function(move) {
                return {
                  x: loon.x,
                  y: loon.y,
                  move: move,
                  wind: getWind(problem, loon.x, loon.y, loon.altitude + move)
                };
              })
              .filter(function(moveAndWind) {
                return _.inRange(loon.y + moveAndWind.wind.y, 0, problem.ny);
              })
              .sample();
          })
          .each(function updateLoonsPositions(moveAndWind, iloon) {
            var loon = loons[iloon];
            if (!loon.moves) {
              loon.moves = [];
            }
            if (!moveAndWind && !loon.isLost) { // we just lost a loon
              //console.warn("loon", iloon, "lost at step", istep);
              loon.isLost = true;
              // _.each(getPossibleMoves(problem, loon), function(move) {
              //   console.log("loon", iloon, loon.x, loon.y, loon.altitude, "move", move, "wind", getWind(problem, loon.x, loon.y, loon.altitude + move));
              // });
            }
            if (loon.isLost) {
              loon.moves.push(0);
              return;
            }
            loon.altitude += moveAndWind.move;
            loon.x = (loon.x + moveAndWind.wind.x) % problem.nx;
            if (loon.x < 0) loon.x += problem.nx; // modulo doest take care of negative values
            loon.y += moveAndWind.wind.y;
            loon.moves.push(moveAndWind.move);
            loon.score = (loon.score || 0) + problem.heatMap[loon.y][loon.x];
            if (loon.altitude !== 0) {
              var nbLoonLimit = 1;
              _.each(xLimit, function(distX) {
                _.each(yLimit, function(distY) {
                  var dx = loon.x + distX % problem.nx;
                  if (dx < 0) dx += problem.nx;
                  var dy = loon.y + distY;
                  if (_.contains(loons, {x: dx, y: dy})) {
                    nbLoonLimit += 1;
                  }
                });
              });
              if (nbLoonLimit === 1) {
                loon.score = (loon.score || 0) + (problem.heatMap[loon.y][loon.x]);
              } else {

              }
            } else {
              loon.score = (loon.score || 0);
            }
            /*
             problem.heatMap[loon.y][loon.x] = 0;
             _.each(_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2), function(dx) {
             _.each(_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2), function(dy) {
             dx = loon.x + dx % problem.nx;
             if (dx < 0) dx += problem.nx;
             problem.heatMap[Math.min(loon.y + dy, problem.ny)][dx] = 0;
             }));
             }));
             */

          })
          .value();
      });
      var currentBestPathForChild = _(loons).sortByAll("score", "id").reverse().uniq("id").sortBy("id").take(problem.nloons).value();
      currentScore = _.sum(currentBestPathForChild, "score");
      if (bestScoreForChild < currentScore) {
        bestScoreForChild = currentScore;
        bestOneForChild = currentBestPathForChild;
      }
    });
      //sort and get the best after the iteration
    process.send({score: bestScoreForChild, path: bestOneForChild});
    process.exit(0);
  }
}

function finishTheWork(moves) {
  var output = unparse(moves);
  var outputFile = process.argv[3] || "./output.txt";
  fs.writeFile(outputFile, output, function(writeFileErr) {
    if (writeFileErr) throw writeFileErr;
  });
}


function transpose(arr) {
  return Object.keys(arr[0]).map(function(c) {
    return arr.map(function(r) {
      return r[c];
    });
  });
}

function getPossibleMoves(problem, loon) {
  if (loon.altitude === 0) return [1];
  if (loon.altitude === 1) return [0, 1];
  if (loon.altitude === problem.nz) return [-1, 0];
  else return [-1, 0, 1];
}

function getWind(problem, x, y, altitude) {
  if (altitude === 0) return {x: 0, y: 0}; // no wind on the ground
  var wz = problem.winds[altitude - 1];
  if (wz) var wy = wz[y];
  if (wy) var wind = wy[x];
  if (!wind) throw new Error("no wind at " + x + " " + y + " " + altitude);
  return wind;
}

function delay(problem, moves, time) {
  var values = _.range(0, time, 0).concat(_.slice(moves, 0, moves.length - time));
  if (values.length !== problem.nsteps) {
    values.concat(_.range(0, problem.nsteps - values.length, 0));
  }
  return values;
}
