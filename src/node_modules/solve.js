"use strict";

var _ = require("lodash");
var parse = require("parse");
var unparse = require("unparse");

module.exports = _.flow(parse, solve, unparse);

function solve(problem) {
  problem.heatMap = getHeatMap(problem);
  var loons = _.times(problem.nloons, function(iloon) {
    return _.assign({id: iloon, altitude: 0}, problem.home);
  });
  return _.times(problem.nsteps, function(istep) {
    return _(loons)
      .map(function chooseMove(loon) {
        if (loon.isLost) return {move: 0};
        var possibleMoves = getPossibleMoves(problem, loon);
        return _(possibleMoves)
          .map(function(move) {
            return {
              x: loon.x,
              y: loon.y,
              move: move,
              wind: getWind(problem, loon.x, loon.y, loon.altitude + move)
            };
          })
          // .tap(console.log.bind(console))
          .filter(function(moveAndWind) {
            return _.inRange(loon.y + moveAndWind.wind.y, 0, problem.ny);
          })
          .sample();
      })
      .each(function updateLoonsPositions(moveAndWind, iloon) {
        var loon = loons[iloon];
        if (loon.isLost || !moveAndWind) {
          loon.isLost = true;
          if (!moveAndWind) console.log("lost!", istep, iloon);
          return;
        }
        loons[iloon].altitude += moveAndWind.move;
        loons[iloon].x = (loons[iloon].x + moveAndWind.wind.x) % problem.nx;
        if (loons[iloon].x < 0) loons[iloon].x += problem.nx;
        loons[iloon].y += moveAndWind.wind.y;
      })
      .map("move")
      .tap(function(moves) {
        console.log(moves.length);
      })
      .value();
  });
}

function getPossibleMoves(problem, loon) {
  if (loon.altitude === 0) return [1];
  if (loon.altitude === 1) return [0, 1];
  if (loon.altitude === problem.nz) return [-1, 0];
  else return [-1, 0, 1];
}

function getWind(problem, x, y, altitude) {
  var wz = problem.winds[altitude - 1];
  if (wz) var wy = problem.winds[y];
  if (wy) var wind = problem.winds[x];
  return wind || {x: 0, y: 0};
}

function getHeatMap(problem) {
  var heatMap = [];
  _.times(problem.ny, function(y) {
    heatMap.push([]);
    _.times(problem.nx, function(x) {
      var current = {x: x, y: y};
      heatMap[y][x] = _(problem.targets).filter(function(target) {
        return isCovered(problem, current, target);
      }).size();
    });
  });
  return heatMap;
}

function isCovered(problem, balloon, target) {
  var distX = balloon.x - target.x;
  var colDist = Math.abs(balloon.y - target.y);
  var columnDist = Math.min(colDist, problem.nx - colDist);
  return Math.pow(distX, 2) + Math.pow(columnDist, 2) <= Math.pow(problem.range, 2);
}

