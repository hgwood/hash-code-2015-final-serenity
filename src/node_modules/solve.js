"use strict";

var _ = require("lodash");
var parse = require("parse");
var unparse = require("unparse");

module.exports = _.flow(parse, solve, unparse);

var DIFFERENT_PATHS = 21  ;

function solve(problem) {
  problem.heatMap = getHeatMap(problem);
  var bestOnesOver = [];
  _.times(500, function() {

    var loons = _.times(problem.nloons, function(iloon) {
      return _.assign({id: iloon, altitude: 0}, problem.home);
    });
    _.times(problem.nsteps, function(istep) {
      return _(loons)
        .map(function chooseMove(loon) {
          if (loon.isLost) return;
          var possibleMoves = getPossibleMoves(problem, loon);
          return _(possibleMoves)
            .map(function(move) {
              return {
                x: loon.x,
                y: loon.y,
                move: move,
                wind: getWind(problem, loon.x, loon.y, loon.altitude + move)
              };
            })
            .filter(function(moveAndWind) {
              return _.inRange(loon.y + moveAndWind.wind.y, 0, problem.ny);
            })
            .sample();
        })
        .each(function updateLoonsPositions(moveAndWind, iloon) {
          var loon = loons[iloon];
          if (!moveAndWind && !loon.isLost) { // we just lost a loon
            //console.warn("loon", iloon, "lost at step", istep);
            loon.isLost = true;
            // _.each(getPossibleMoves(problem, loon), function(move) {
            //   console.log("loon", iloon, loon.x, loon.y, loon.altitude, "move", move, "wind", getWind(problem, loon.x, loon.y, loon.altitude + move));
            // });
          }
          if (loon.isLost) return;
          loon.altitude += moveAndWind.move;
          loon.x = (loon.x + moveAndWind.wind.x) % problem.nx;
          if (loon.x < 0) loon.x += problem.nx; // modulo doest take care of negative values
          loon.y += moveAndWind.wind.y;
          if (!loon.moves) {
            loon.moves = [];
          }
          loon.moves.push(moveAndWind.move || 0);
          loon.score = (loon.score || 0) + problem.heatMap[loon.y][loon.x];
          problem.heatMap[loon.y][loon.x] = 0;
          _.each(_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2), function(dx) {
            _.each(_.range(Math.ceil(-problem.range/2), Math.floor(+problem.range/2), function(dy) {
              dx = loon.x + dx % problem.nx;
              if (dx < 0) dx += problem.nx;
              problem.heatMap[Math.min(loon.y + dy, problem.ny)][dx] = 0;
            }));
          }));
        })
        .map("move")
        .map(function(move) {
          return move || 0; // replace undefined generated from lost loons
        })
        .value();
    });
    var bestOnes = _(loons).filter(function(loon) {
      return loon.moves.length === problem.nsteps;
    }).sortBy("score").take(DIFFERENT_PATHS).value();
    bestOnesOver.push(bestOnes);
  });
  /*
   var highY = _(bestOnesOver).flatten().sortBy("score").filter(function(best) {
   return best.moves[20].y > 20 || best.moves[21].y > 20;
   }).takeRight(DIFFERENT_PATHS).value();
   bestOnesOver = _(bestOnesOver).flatten().uniq("score").sortBy("score").takeRight(DIFFERENT_PATHS).value();
   var delayEach = [1, 2, 3];
   var paths = _.times(problem.nloons, function(iloon) {
   var pathToUse;
   if (iloon % 5 === 0) {
   pathToUse = highY;
   } else {
   pathToUse = bestOnesOver;
   }
   //return bestOnesOver[iloon % DIFFERENT_PATHS].moves;
   var timerOfLaunch = [iloon];
   if (iloon > 1 && iloon < problem.nsteps) {
   timerOfLaunch = [iloon - 1, iloon, iloon + 1];
   //var path = _sample([highY, bestOnesOver])[iloon % DIFFERENT_PATHS];
   }
   if(!pathToUse[iloon % DIFFERENT_PATHS]) {
   pathToUse = bestOnesOver;
   }
   return delay(problem, pathToUse[iloon % DIFFERENT_PATHS].moves, _.sample(delayEach) * iloon);
   */
  bestOnesOver = _(bestOnesOver).flatten().sortBy("score").takeRight(DIFFERENT_PATHS).value();
  var delayEach = 1;
  var paths = _.times(problem.nloons, function(iloon) {
    //return bestOnesOver[iloon % DIFFERENT_PATHS].moves;
    return delay(problem, bestOnesOver[iloon % DIFFERENT_PATHS].moves, delayEach * iloon);
  });
  var res = transpose(paths);
  return res;

}

function transpose(arr) {
  return Object.keys(arr[0]).map(function(c) {
    return arr.map(function(r) {
      return r[c];
    });
  });
}

function getPossibleMoves(problem, loon) {
  if (loon.altitude === 0) return [1];
  if (loon.altitude === 1) return [0, 1];
  if (loon.altitude === problem.nz) return [-1, 0];
  else return [-1, 0, 1];
}

function getWind(problem, x, y, altitude) {
  if (altitude === 0) return {x: 0, y: 0}; // no wind on the ground
  var wz = problem.winds[altitude - 1];
  if (wz) var wy = wz[y];
  if (wy) var wind = wy[x];
  if (!wind) throw new Error("no wind at " + x + " " + y + " " + altitude);
  return wind;
}

function getHeatMap(problem) {
  var heatMap = [];
  _.times(problem.ny, function(y) {
    heatMap.push([]);
    _.times(problem.nx, function(x) {
      var current = {x: x, y: y};
      heatMap[y][x] = _(problem.targets).filter(function(target) {
        return isCovered(problem, current, target);
      }).size();
    });
  });
  return heatMap;
}


function delay(problem, moves, time) {
  var values = _.range(0, time, 0).concat(_.slice(moves, 0, moves.length - time));
  if (values.length !== problem.nsteps) {
    values.concat(_.range(0, problem.nsteps - values.length, 0));
  }
  return values;
}

function isCovered(problem, balloon, target) {
  var distX = balloon.x - target.x;
  var colDist = Math.abs(balloon.y - target.y);
  var columnDist = Math.min(colDist, problem.nx - colDist);
  return Math.pow(distX, 2) + Math.pow(columnDist, 2) <= Math.pow(problem.range, 2);
}

function selectBestWinds(problem, moveAndWinds) {
  var x = moveAndWinds[0].x;
  var y = moveAndWinds[0].y;
  var moveAndWindAndForces = _.map(moveAndWinds, function(moveAndWind) {
    return _.assign({}, moveAndWind, {windForce: force(moveAndWind.wind)});
  });
  if (problem.heatMap[y][x] <= 500) {
    return _.max(moveAndWindAndForces, function(moveAndWind) {
      return moveAndWind.windForce;
    });
  } else {
    return _.min(moveAndWindAndForces, function(moveAndWind) {
      return moveAndWind.windForce;
    });
  }
}

function force(windVector) {
  return Math.pow(windVector.x, 2) + Math.pow(windVector.y, 2);
}
